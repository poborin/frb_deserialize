// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.4.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

class CycleElement {
  /// Type of cycle
  final CycleType cycleType;

  /// End date of the cycle or phase
  final String endDate;

  /// Name or description of the cycle or phase
  final String name;
  final List<PhaseElement> phases;
  final List<SessionElement> sessions;

  /// Start date of the cycle or phase
  final String startDate;

  /// Nested cycles for finer planning
  final List<CycleElement> subCycles;
  final Target target;

  const CycleElement({
    required this.cycleType,
    required this.endDate,
    required this.name,
    required this.phases,
    required this.sessions,
    required this.startDate,
    required this.subCycles,
    required this.target,
  });

  @override
  int get hashCode =>
      cycleType.hashCode ^
      endDate.hashCode ^
      name.hashCode ^
      phases.hashCode ^
      sessions.hashCode ^
      startDate.hashCode ^
      subCycles.hashCode ^
      target.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CycleElement &&
          runtimeType == other.runtimeType &&
          cycleType == other.cycleType &&
          endDate == other.endDate &&
          name == other.name &&
          phases == other.phases &&
          sessions == other.sessions &&
          startDate == other.startDate &&
          subCycles == other.subCycles &&
          target == other.target;
}

/// Type of cycle
enum CycleType {
  inSeason,
  macrocycle,
  mesocycle,
  microcycle,
  offSeason,
  postSeason,
  preSeason,
  ;
}

/// Day of the week for the training session
enum Day {
  friday,
  monday,
  saturday,
  sunday,
  thursday,
  tuesday,
  wednesday,
  ;
}

/// Training phase
enum Phase {
  inSeason,
  offSeason,
  postSeason,
  preSeason,
  ;
}

class PhaseElement {
  /// Training phase
  final Phase phase;

  /// Number of weeks in the phase
  final int weeks;

  const PhaseElement({
    required this.phase,
    required this.weeks,
  });

  @override
  int get hashCode => phase.hashCode ^ weeks.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PhaseElement &&
          runtimeType == other.runtimeType &&
          phase == other.phase &&
          weeks == other.weeks;
}

class SessionElement {
  /// Day of the week for the training session
  final Day day;

  /// Duration of the training session
  final String duration;

  /// Focus areas of the training session
  final String focusAreas;

  /// Intensity level of the training session
  final String intensity;

  /// Additional notes for the training session
  final String notes;

  /// Focus areas for recovery sessions (e.g., flexibility, relaxation)
  final String recoveryFocus;

  /// Specific details or exercises for rehabilitation
  final String rehabDetails;

  /// Start time of the training session
  final String startTime;

  /// Type of training session
  final String coordinatType;

  const SessionElement({
    required this.day,
    required this.duration,
    required this.focusAreas,
    required this.intensity,
    required this.notes,
    required this.recoveryFocus,
    required this.rehabDetails,
    required this.startTime,
    required this.coordinatType,
  });

  @override
  int get hashCode =>
      day.hashCode ^
      duration.hashCode ^
      focusAreas.hashCode ^
      intensity.hashCode ^
      notes.hashCode ^
      recoveryFocus.hashCode ^
      rehabDetails.hashCode ^
      startTime.hashCode ^
      coordinatType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SessionElement &&
          runtimeType == other.runtimeType &&
          day == other.day &&
          duration == other.duration &&
          focusAreas == other.focusAreas &&
          intensity == other.intensity &&
          notes == other.notes &&
          recoveryFocus == other.recoveryFocus &&
          rehabDetails == other.rehabDetails &&
          startTime == other.startTime &&
          coordinatType == other.coordinatType;
}

class Target {
  /// Name of individual athlete or team
  final String name;

  /// Target audience type
  final Type targetType;

  const Target({
    required this.name,
    required this.targetType,
  });

  @override
  int get hashCode => name.hashCode ^ targetType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Target &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          targetType == other.targetType;
}

class TrainingPlan {
  final List<CycleElement> cycles;

  /// training plan title
  final String title;

  const TrainingPlan({
    required this.cycles,
    required this.title,
  });

  static TrainingPlan testDeserialize({required String content}) =>
      RustLib.instance.api
          .crateApiTrainingPlanTrainingPlanTestDeserialize(content: content);

  static Future<TrainingPlan> testDeserializeAsync({required String content}) =>
      RustLib.instance.api.crateApiTrainingPlanTrainingPlanTestDeserializeAsync(
          content: content);

  static void testPanic() =>
      RustLib.instance.api.crateApiTrainingPlanTrainingPlanTestPanic();

  @override
  int get hashCode => cycles.hashCode ^ title.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TrainingPlan &&
          runtimeType == other.runtimeType &&
          cycles == other.cycles &&
          title == other.title;
}

/// Target audience type
enum Type {
  individual,
  team,
  ;
}
